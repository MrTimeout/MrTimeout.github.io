[ { "title": "Redis Getting Started", "url": "/posts/getting-started-redis/", "categories": "Database, Redis", "tags": "Redis, Database, Getting Started", "date": "2019-08-09 14:55:00 +0200", "snippet": "This post will guide you how to get your hands on Redis. If you are a totally beginner, this can help you to start.I am a totally beginner using this technology, so contact me if there is something wrong with the blog or you want to connect.I am creating a series of Redis to learn more about it. Happy coding.What is Redis?Redis is an open source, in-memory data store used by millions of developers as a database, cache, streaming engine, and message brokerInstallWe are going to use Docker because it is really simple to get start and running.Three linesREDIS_ID=$(docker container run --publish 6379:6379 --rm --detach redis:latest)docker container ls --all --format \"\" $REDIS_IDdocker container exec -it $REDIS_ID redis-cliOne linerdocker container exec -it \\ $(docker container run --publish 6379:6379 --rm --detach redis:latest) redis-cliData typesIn redis, we have various data types to play with: string hash list set ordered set streams geospatial hyperLogLog Bitmaps BitFieldsWell, it sounds interesting, but less talk and more action." }, { "title": "Redis String Data Type", "url": "/posts/data-type-string/", "categories": "Database, Redis", "tags": "Redis, Database, String", "date": "2019-08-09 14:55:00 +0200", "snippet": "This post will guide you how to get your hands on Redis with String data type.String typeStrings just store sequences of bytes, including text, serialized arrays and binary arrays.So, how can we store them in redis database? Let’s seeSetting and getting stringsWe can create a key with a string value in different ways:# Create the key \"greeting:1\" with the value \"Hello\" inside of it.&gt; SET greeting:1 \"Hello\"\"OK\"# Retrieve the value stored inside of the key&gt; GET greeting:1\"Hello\"# We can set multiple keys at the same time (being an atomic operation) instead of executing n \"set\" commands.&gt; MSET greeting:2 \"Bye\" greeting:3 \"Good morning\" greeting:4 \"Good afternoon\"\"OK\"# How many keys we have inserted?&gt; KEYS greeting:*1) \"greeting:4\"2) \"greeting:3\"3) \"greeting:2\"4) \"greeting:1\"# That's OK, but I want its values&gt; MGET greeting:1 greeting:2 greeting:3 greeting:4 notexistent1) \"Hello\"2) \"Bye\"3) \"Good morning\"4) \"Good afternoon\"5) \"null\"# Same applies to get only one key string&gt; GET greeting:1\"Hello\"# We can also check if the variable exists before trying to set it to a value. 1 == True and 0 == False&gt; EXISTS greeting:5(integer) 0# It doesn't exists, so we will create one&gt; SET greeting:5 \"Good night\"\"OK\"# What could happen if while we check the existence of the key, other user tries to# insert its own key? It can be a little messy, so Redis give us the option to check# key and set if not existent in the same command, so it is thread-safe.&gt; SETNX greeting:6 \"Hola\"(integer) 1# If we execute the command anothe time. OK, the key is already set so we are fine.&gt; SETNX greeting:6 \"Hola\"(integer) 0# Ouch, I wrote the wrong value inside of greeting:6. I want to delete that key retrieving its value&gt; GETDEL greeting:6\"Hola\"# Check if it was deleted correctly. Perfect! It was.&gt; EXISTS greeting:6(integer) 0Expiring string keysWhat about expiring keys? We can set a time in seconds/milliseconds/unix-time-seconds/unix-time-milliseconds/keepttl to expire the key when it times out.Time is expressed as: EX &lt;seconds&gt;: EXpire seconds PX &lt;milliseconds&gt;: eXPire milliseconds EXAT &lt;unix-time-seconds&gt;: EXpire AT unix-time-seconds PXAT &lt;unix-time-milliseconds&gt;: eXPire AT unix-time-milliseconds KEEPTTL: When modifying value of a key, we maintain the already set expire time# Create a key string with expire time set to 2 hours. Here 1000 represents the User ID&gt; SET session:1000 \"cookie\" EX 7200\"OK\"# Create a key string with expire time set to 1 hour in milliseconds.&gt; SET session:1000 \"cookie\" PX 3600000\"OK\"# Update a key if it already exists and maintaining the expire time. We also return the previous# stored value.&gt; SET session:1000 \"cookie value\" GET XX KEEPTTL\"cookie\"# Set a key if it doesn't exist with unix-time-seconds# Current time : 2022-08-18 12:40:00 (date -d \"2022-08-18 12:40:00\" +%s)# EXpire AT time: 2022-08-18 12:45:00 (date -d \"2022-08-18 12:45:00\" +%s)&gt; SET session:1001 \"another cookie value\" NX EXAT 1660819500\"OK\"# After 5 minutes, we check if the key is still alive&gt; GET session:1001# Set a key if it doesn't exist with unix-time-milliseconds# Current time : 2022-08-18 12:40:00 (date -d \"2022-08-18 12:40:00\" +%s)# EXpire AT time: 2022-08-18 12:45:00 (date -d \"2022-08-18 12:45:00\" +%s)&gt; SET session:1002 \"another cookie value\" NX PXAT 1660819500000\"OK\"# After 5 minutes, we check if the key is still alive&gt; GET session:1002CommandsSet SET &lt;key&gt; &lt;value&gt; [NX | XX] [GET] [EX &lt;seconds&gt; | PX &lt;milliseconds&gt; | EXAT &lt;unix-time-seconds&gt; | PXAT &lt;unix-time-milliseconds&gt; | KEEPTTL]: NX: Not eXistent. XX: EXXistent. GET: GET the old value when updating and null when not existent. EX: EXpire in seconds. PX: eXPire in milliseconds. EXAT: EXpire AT unix-time-seconds date +%s PXAT: eXPire AT unix-time-milliseconds echo $(($(date +%s) * 1000)) KEEPTTL: keep the expire time set when updating value of the key. TTL -&gt; Time To Live. SETNX &lt;key&gt; &lt;value&gt;: SET if Not eXistent. Similar to SET &lt;key&gt; &lt;value&gt; NX. SETEX &lt;key&gt; &lt;expire-time-seconds&gt; &lt;value&gt;: SET a key with value and EXpiration time in seconds. Similar to SET &lt;key&gt; &lt;value&gt; EX &lt;expire-time-seconds&gt;. PSETEX &lt;key&gt; &lt;expire-time-milliseconds&gt; &lt;value&gt;: SET a key with value and eXPiration time in milliseconds. Similar to SET &lt;key&gt; &lt;value&gt; PX &lt;expire-time-milliseconds&gt;. MSET &lt;key&gt; &lt;value&gt; [&lt;key&gt; &lt;value&gt;...]: SET Multiple keys with values in one command. This action is atomic (all keys are set at the same time). MSETNX &lt;key&gt; &lt;value&gt; [&lt;key&gt; &lt;value&gt;...]: SET Multiple keys with values in one command if they don’t exists (the ones that already exist, are skipped). This action is atomic (all keys are set at the same time).Get GET &lt;key&gt;: It returns the value of the key and if it does not exists, it returns null GETDEL &lt;key&gt;: It returns the value of the key and deletes it. GETEX &lt;key&gt; [EX &lt;seconds&gt; | PX &lt;milliseconds&gt; | EXAT &lt;unix-time-seconds&gt; | PXAT &lt;unix-time-milliseconds&gt; | PERSIST]: PERSIST: Remove the time to live associated with the key. GETRANGE &lt;key&gt; &lt;start&gt; &lt;end&gt;: being mykey “Hello” GETRANGE mykey 0 2 returns “Hel” GETRANGE mykey -2 -1 returns “ol GETRANGE mykey 0 10000 returns “Hello”. There are not out of bounds. GETSET &lt;key&gt; &lt;value&gt;: Set a new value to a key and retrieve the old value. Deprecated in Redis version 6.2.0 Replaced with: SET &lt;key&gt; &lt;value&gt; GETOperations APPEND &lt;key&gt; &lt;value&gt;: If key exists, it appends the value at the end of the actual value. If key does not exists, it creates the key with the appended value. LCS &lt;key1&gt; &lt;key2&gt; [LEN] [IDX] [MIMMATCHLEN len] [WITHMATCHLEN]: LCS means Longest Common Subsequence. This is not the same as LCS (Longest Common String), which means that characters do not to be contiguos. LEN: To get the length of the string. IDX: get the position of each string. MIMMATCHLEN: Print only the ones that have the minimum “len” passed as a parameter. WITHMATCHLEN: Print also the length of each match. Reference STRING SET SETNX SETEX PSETEX MSET MSETNX GET GETDEL GETEX GETRANGE GETSET APPEND" } ]
